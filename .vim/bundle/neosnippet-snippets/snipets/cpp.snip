snippet     defines
    #include <bits/stdc++.h>
    
    using namespace std;
    
    //#define int long long
    
    using ll = long long;
    using pii =  pair<int, int>;
    
    const int IINF =  0x3f3f3f3f;
    const ll LINF = 0x3f3f3f3f3f3f3f3fLL;
    const int INF = sizeof(int) == sizeof(long long) ? LINF : IINF;
    const ll MOD = 1e9+7;
    
    #define for_(i,a,b) for(int i = (a);i < (b);i++)
    #define rfor_(i,a,b) for(int i = (b)-1;i >= (a);i--)
    
    #define rep(i,n) for_(i,0,n)
    #define rrep(i,n) rfor_(i,0,n)
    
    #define pb push_back
    //#define eb emplace_back
    #define mp make_pair
    #define ft first
    #define sd second
    
    #define all(a) (a).begin(), (a).end()
    #define sz(a) (int)(a).size()
    #define rev(a) reverse(all(a))
    
    #define endl '\n'
    ${1}

snippet	 binarysearchtree
options	 head
	struct node {
		int val;
		node *lch, *rch;
	};
	// 数 x を追加
	node *insert(node *p, int x) {
		if (p == NULL) {
			node *q = new node;
			q->val = x;
			q->lch = q->rch = NULL;
			return q;
		}
		else {
			if (x < p->val) p->lch = insert(p->lch, x);
			else p->rch = insert(p->rch, x);
			return p;
		}
	}
	// 数 x を検索
	bool find(node *p, int x) {
		if (p == NULL) return false;
		else if (x == p->val) return true;
		else if (x < p->val) return find(p->lch, x);
		else return find(p->rch, x);
	}
	// 数 x を削除
	node *remove(node *p, int x) {
		if (p == NULL) return NULL;
		else if (x < p->val) p->lch = remove(p->lch, x);
		else if (x > p->val) p->rch = remove(p->rch, x);
		else if (p->lch == NULL) {
			node *q = p->rch;
			delete p;
			return q;
		}
		else if (p->lch->rch == NULL) {
			node *q = p->lch;
			q->rch = p->rch;
			delete p;
			return q;
		}
		else {
			node *q;
			for (q = p->lch; q->rch->rch != NULL; q = q->rch);
			node *r = q->rch;
			q->rch = r->lch;
			r->lch = p->lch;
			r->rch = p->rch;
			delete p;
			return r;
		}
		return p;
	}
	${1}

snippet	 unionfindtree
	int par[MAX_N]; // 親
	int rank[MAX_N]; // 木の深さ
	// n 要素で初期化
	void init(int n) {
		for (int i = 0; i < n; i++) {
			par[i] = i;
			rank[i] = 0;
		}
	}
	// 木の根を求める
	int find(int x) {
		if (par[x] == x) {
			return x;
		} else {
			return par[x] = find(par[x]);
		}
	}
	// x と y の属する集合を併合
	void unite(int x, int y) {
		x = find(x);
		y = find(y);
		if (x == y) return;
		if (rank[x] < rank[y]) {
			par[x] = y;
		} else {
			par[y] = x;
			if (rank[x] == rank[y]) rank[x]++;
		}
	}
	// x と y が同じ集合に属するか否か
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	${1}
